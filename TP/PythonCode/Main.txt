# Crear archivo Python que ejecuta todas las consultas SQL y genera gr√°ficos

import pyodbc
import pandas as pd
import matplotlib.pyplot as plt
import os
import numpy as np
import seaborn as sns

# Conexi√≥n a SQL Server
conn = pyodbc.connect(
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=157.92.26.17,1443;'
    'DATABASE=AdventureWorks2019;'
    'UID=Alumno;'
    'PWD=mrcd2025;'
)

# Ruta a las consultas SQL
sql_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'SQL'))

def ejecutar_query(nombre_archivo_sql):
    ruta = os.path.join(sql_dir, nombre_archivo_sql)
    with open(ruta, 'r', encoding='utf-8') as f:
        query = f.read()
    return pd.read_sql_query(query, conn)


df1 = ejecutar_query('consulta_geo.sql')
print(df1)

# 1. Tiempo de entrega por pedido - Histograma
df1 = ejecutar_query('tiempo_entrega_por_pedido.sql')
plt.figure(figsize=(10, 6))
plt.hist(df1['DeliveryDays'], bins=20, color='skyblue', edgecolor='black')
plt.title('Distribuci√≥n de Tiempos de Entrega (d√≠as)')
plt.xlabel('D√≠as de Entrega')
plt.ylabel('Cantidad de Pedidos')
plt.tight_layout()
plt.show()



delivery_days = df1['DeliveryDays'].dropna()

# Cuartiles e IQR
q1 = delivery_days.quantile(0.25)
q3 = delivery_days.quantile(0.75)
iqr = q3 - q1

print("Q1:", q1)
print("Q3:", q3)
print("IQR (rango intercuartil):", iqr)

# Estad√≠sticas b√°sicas
print("Promedio:", delivery_days.mean())
print("Mediana:", delivery_days.median())
print("Moda:", delivery_days.mode().values[0])
print("Desv√≠o est√°ndar:", delivery_days.std())
print("M√≠nimo:", delivery_days.min())
print("M√°ximo:", delivery_days.max())




# 4. Motivos de devoluciones - Gr√°fico circular
df4 = ejecutar_query('motivos_devoluciones.sql')
plt.figure(figsize=(8, 6))
plt.pie(df4['TotalReturns'], labels=df4['Reason'], autopct='%1.1f%%', startangle=140)
plt.title('Motivos de Devoluci√≥n')
plt.tight_layout()
plt.show()

# 5. Devoluciones por producto - Barras horizontales
df5 = ejecutar_query('devoluciones_por_producto.sql').head(10)
plt.figure(figsize=(10, 6))
plt.barh(df5['Product'], df5['ReturnCount'], color='salmon')
plt.title('Top 10 Productos con M√°s Devoluciones')
plt.xlabel('Cantidad de Devoluciones')
plt.tight_layout()
plt.show()

# 6. Devoluciones por territorio - Barras horizontales
df6 = ejecutar_query('devoluciones_por_territorio.sql')
df6.sort_values('ReturnCount', ascending=False, inplace=True)
plt.figure(figsize=(10, 6))
plt.barh(df6['Territory'], df6['ReturnCount'], color='mediumpurple')
plt.title('Devoluciones por Territorio')
plt.xlabel('Cantidad de Devoluciones')
plt.tight_layout()
plt.show()

#7. Devoluciones por subcategor√≠a - Barras horizontales
df7 = ejecutar_query('devoluciones_por_subcategoria.sql')
df7.sort_values('ReturnCount', ascending=True, inplace=True)
plt.figure(figsize=(10, 6))
plt.barh(df7['Subcategory'], df7['ReturnCount'], color='darkcyan')
plt.title('Devoluciones por Subcategor√≠a de Producto')
plt.xlabel('Cantidad de Devoluciones')
plt.tight_layout()
plt.show()

# 8. Devoluciones por categor√≠a - Barras horizontales
df8 = ejecutar_query('devoluciones_por_categoria.sql')
df8.sort_values('ReturnCount', ascending=True, inplace=True)
plt.figure(figsize=(8, 5))
plt.barh(df8['Category'], df8['ReturnCount'], color='steelblue')
plt.title('Devoluciones por Categor√≠a de Producto')
plt.xlabel('Cantidad de Devoluciones')
plt.tight_layout()
plt.show()

# 9. Tasa de devoluci√≥n por producto
df9 = ejecutar_query('tasa_devolucion_por_producto.sql').head(10)
plt.figure(figsize=(10, 6))
plt.barh(df9['Product'], df9['ReturnRate'], color='firebrick')
plt.title('Tasa de Devoluci√≥n por Producto')
plt.xlabel('Tasa de Devoluci√≥n (Proporci√≥n)')
plt.tight_layout()
plt.show()

# 10. Tasa de devoluci√≥n por subcategor√≠a
df10 = ejecutar_query('tasa_devolucion_por_subcategoria.sql').head(50)
plt.figure(figsize=(10, 6))
plt.barh(df10['Subcategory'], df10['ReturnRate'], color='darkorange')
plt.title('Tasa de Devoluci√≥n por Subcategor√≠a')
plt.xlabel('Tasa de Devoluci√≥n (Proporci√≥n)')
plt.tight_layout()
plt.show()

# 11. Tasa de devoluci√≥n por categor√≠a
df11 = ejecutar_query('tasa_devolucion_por_categoria.sql')
plt.figure(figsize=(8, 5))
plt.barh(df11['Category'], df11['ReturnRate'], color='seagreen')
plt.title('Tasa de Devoluci√≥n por Categor√≠a')
plt.xlabel('Tasa de Devoluci√≥n (Proporci√≥n)')
plt.tight_layout()
plt.show()

# 12. Tasa de devoluci√≥n por territorio
df12 = ejecutar_query('tasa_devolucion_por_territorio.sql')
df12.sort_values('ReturnRate', ascending=True, inplace=True)
plt.figure(figsize=(10, 6))
plt.barh(df12['Territory'], df12['ReturnRate'], color='royalblue')
plt.title('Tasa de Devoluci√≥n por Territorio')
plt.xlabel('Tasa de Devoluci√≥n (Proporci√≥n)')
plt.tight_layout()
plt.show()

# 13. Distancia entre tienda y destino de env√≠o
df13 = ejecutar_query('distancia_ventas_por_tienda.sql')

# Boxplot de distancias por tienda (top 10 por cantidad de registros)
top_tiendas = df13['StoreName'].value_counts().head(10).index
df_top = df13[df13['StoreName'].isin(top_tiendas)]


# Calcular el promedio de distancia por tienda
store_avg_distance = df_top.groupby('StoreName')['DistanceKm'].mean().sort_values(ascending=False)

# Ordenar df_top por el promedio de distancia de mayor a menor
df_top['StoreName'] = pd.Categorical(df_top['StoreName'], categories=store_avg_distance.index, ordered=True)
df_top = df_top.sort_values('StoreName')

# Crear figura y tama√±o del gr√°fico
plt.figure(figsize=(12, 6))

# Crear el boxplot de distancias por tienda (ordenado)
ax = df_top.boxplot(column='DistanceKm', by='StoreName', grid=False, rot=45)

# Agregar los puntos individuales (scatter plot) sobre el boxplot
for i, store_name in enumerate(store_avg_distance.index, start=1):
    store_data = df_top[df_top['StoreName'] == store_name]
    plt.scatter([i] * len(store_data), store_data['DistanceKm'], alpha=0.5, color='blue')

# Personalizar el gr√°fico
plt.title('Distribuci√≥n de Distancias entre Tienda y Entrega')
plt.suptitle('')  # Eliminar el t√≠tulo por defecto
plt.xlabel('Tienda')
plt.ylabel('Distancia (km)')

# Ajustar el dise√±o y mostrar el gr√°fico
plt.tight_layout()
plt.show()


# 6. Ganancias por territorio - Barras horizontales
df14 = ejecutar_query('ganancia.sql')
plt.figure(figsize=(10, 6))
plt.barh(df14['Territorio'], df14['GananciaTotal'], color='lightgreen')
plt.title('Ganancia Total por Territorio')
plt.xlabel('Ganancia Total')
plt.tight_layout()
plt.show()

# 1. Ganancia por A√±o
df_ano = ejecutar_query('ganancia_por_a√±o.sql')
df_ano.plot(kind='bar', x='Territorio', y='VentaTotal', stacked=True, figsize=(12, 6))
plt.title('Ganancia por Territorio a lo Largo de los A√±os')
plt.xlabel('Territorio')
plt.ylabel('Venta Total')
plt.tight_layout()
plt.show()


# Ejecutar la consulta para obtener los datos pivotados
df = ejecutar_query('ganancia_por_estacion_a√±o.sql')

# Verificar las primeras filas del DataFrame para asegurarse de que la columna 'CambioPorcentual' existe
print(df.head())


sns.set(style="whitegrid")

# Crear una figura para el gr√°fico
plt.figure(figsize=(14, 8))

# Asignar una paleta de colores para los territorios
paleta_colores = sns.color_palette("tab10", n_colors=len(df['Territorio'].unique()))

# Graficar una l√≠nea para cada a√±o y territorio
for i, (territorio, grupo) in enumerate(df.groupby('Territorio')):
    sns.lineplot(data=grupo, x='Estacion', y='CambioPorcentual', label=territorio, color=paleta_colores[i], marker='o')

# Graficar la l√≠nea de tendencia global
sns.regplot(data=df, x="Estacion", y="CambioPorcentual", scatter=False, 
            line_kws={'color': 'black', 'linewidth': 2, 'ls': '--'}, 
            ci=95, label='L√≠nea de tendencia global')

# Personalizar el gr√°fico
plt.title('L√≠neas de Tendencia del Cambio Porcentual de Ganancia por Estaci√≥n y Territorio')
plt.xlabel('Estaci√≥n')
plt.ylabel('Cambio Porcentual de la Ganancia')
plt.legend(title='Territorio', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.xticks(rotation=45)
plt.tight_layout()

# Mostrar el gr√°fico
plt.show()
# 2. Ganancia por Mes y A√±o (Ejemplo: Agrupado por mes y a√±o por territorio)
df_mes_ano = ejecutar_query('ganancia_por_mes_a√±o.sql')

# Crear un FacetGrid para tener un gr√°fico por territorio
g = sns.FacetGrid(df_mes_ano, col="Territorio", col_wrap=4, height=4)  # 4 gr√°ficos por fila
g.map(sns.lineplot, "Mes", "VentaTotal", marker="o", color="coral")

# Personalizar los gr√°ficos
g.set_axis_labels("Mes", "Venta Total")
g.set_titles("{col_name}")
g.set_xticklabels(rotation=45)
g.fig.suptitle('Ganancia por Mes y A√±o para cada Territorio', fontsize=16)
plt.tight_layout()
plt.subplots_adjust(top=0.9)  # Ajustar el t√≠tulo para no sobreponerse
plt.show()

df = ejecutar_query('productos_vendidos_por_estacion.sql')
import matplotlib.pyplot as plt
import seaborn as sns

# Asegurar orden correcto de estaciones
orden_estaciones = ['Primavera', 'Verano', 'Oto√±o', 'Invierno']
df['Estacion'] = pd.Categorical(df['Estacion'], categories=orden_estaciones, ordered=True)

# Configurar figura con subplots (2 filas, 2 columnas)
fig, axs = plt.subplots(2, 2, figsize=(18, 12), sharex=True)
fig.suptitle('Tendencias Estacionales por Territorio (Variaciones Porcentuales)', fontsize=20)

# Variables y t√≠tulos
variaciones = [
    ('VariacionVentas', 'Variaci√≥n Porcentual de Ventas'),
    ('VariacionGananciaTotal', 'Variaci√≥n Porcentual de Ganancia Total'),
    ('VariacionGananciaBruta', 'Variaci√≥n Porcentual de Ganancia Bruta'),
    ('VariacionProductosVendidos', 'Variaci√≥n Porcentual de Productos Vendidos')
]

# Paleta de colores por territorio
territorios = df['Territorio'].unique()
paleta_colores = sns.color_palette("tab10", n_colors=len(territorios))

# Crear gr√°ficos
for ax, (var, titulo) in zip(axs.flat, variaciones):
    for i, (territorio, grupo) in enumerate(df.groupby('Territorio')):
        sns.lineplot(data=grupo, x='Estacion', y=var,
                     label=territorio if ax == axs[1, 1] else "",  # Solo incluir etiquetas en el √∫ltimo para la leyenda
                     color=paleta_colores[i], marker='o', ci=None, ax=ax)

    # L√≠nea de promedio por estaci√≥n
    media_global = df.groupby('Estacion')[var].mean().reset_index()
    sns.lineplot(data=media_global, x='Estacion', y=var,
                 color='black', linewidth=2, linestyle='--',
                 label='Promedio Global' if ax == axs[1, 1] else "", ax=ax)

    ax.set_title(titulo, fontsize=20)
    ax.set_xlabel('', fontsize=14)
    ax.set_ylabel('% Variaci√≥n', fontsize=18)
    ax.tick_params(axis='both', labelsize=16)
    ax.tick_params(axis='x')
    # ‚ùå Eliminar leyenda local del subplot (si existe)
    if ax.get_legend() is not None:
        ax.get_legend().remove()

# Leyenda abajo (fuera de la grilla)
handles, labels = axs[1, 1].get_legend_handles_labels()
fig.legend(handles, labels, title='Territorio', fontsize=16, title_fontsize=18,
           loc='lower center', bbox_to_anchor=(0.5, -0.03), ncol=4)

plt.tight_layout(rect=[0, 0.05, 1, 0.95])
plt.show()


'''''
# 14. Mapa: Ubicaci√≥n de tiendas y destinos de env√≠o conectados

import folium
from folium.plugins import MarkerCluster

df_map = df13.copy()
df_map = df_map.dropna(subset=['StoreLat', 'StoreLong', 'DeliveryLat', 'DeliveryLong'])

# Crear mapa centrado en un punto medio aproximado
center_lat = df_map['StoreLat'].mean()
center_lon = df_map['StoreLong'].mean()
m = folium.Map(location=[center_lat, center_lon], zoom_start=4)

# Agrupar marcadores por tienda
store_group = MarkerCluster(name="Tiendas").add_to(m)
delivery_group = MarkerCluster(name="Destinos").add_to(m)

# Agregar marcadores de tiendas
for store in df_map[['StoreName', 'StoreLat', 'StoreLong']].drop_duplicates().itertuples(index=False):
    folium.Marker(
        location=[store.StoreLat, store.StoreLong],
        popup=f"Tienda: {store.StoreName}",
        icon=folium.Icon(color='blue', icon='shopping-cart', prefix='fa')
    ).add_to(store_group)

# Agregar l√≠neas entre tienda y destino de env√≠o
for row in df_map.itertuples():
    folium.PolyLine(
        locations=[(row.StoreLat, row.StoreLong), (row.DeliveryLat, row.DeliveryLong)],
        color='red',
        weight=1,
        opacity=0.5
    ).add_to(m)
    
    # Opcional: marcar puntos de entrega (agrupados)
    folium.CircleMarker(
        location=(row.DeliveryLat, row.DeliveryLong),
        radius=2,
        color='green',
        fill=True,
        fill_opacity=0.6
    ).add_to(delivery_group)
    
m.save('mapa_tiendas_envios.html')
print("üåç Mapa guardado como 'mapa_tiendas_envios.html'")
'''''''''